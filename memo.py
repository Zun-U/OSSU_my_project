# 変数xに「2」を記憶させている。(変数「x」に「2」という値をメモリに割り当てている。)
# 記憶するのがPythonの仕事。
# ("="は演算子。物事を行う。)
x = 2


# 「x」を調べて印刷します。(printは予約語)(この時点で「x」に記憶されている値は「2」)
print(x)


# ↑で記憶させた変数「x」を思い出させ、「+2」してまた変数「x」に記憶させている。（つまりこの行で変数「x」に記憶させている値は「4」になる。）
# ("+"は演算子。物事を行う。)
x = x + 2

# 「x」を調べて印刷します。(printは予約語)(この時点で「x」に記憶されている値は「4」)
print(x)


# Pythonは基本的に上から順番にプログラムの各行を実行する。
# その実行順を表したものが「フローチャート」という。


# 条件付きスキップ
x = 5

# 「if」は予約語。
# 「if」は小さな分岐点の様なもの。ある方向に進むことも、別の方向に進むこともできる。
if x < 10: #「xが10以下」であるかどうか、"真"か"偽"(true, false)を判断している。（xが10未満なら「真, true」、xが10以上なら「偽、 false」）(「偽, false」ならコロン「:」直下にある行がスキップされる。)
  print('Smaller') #「真、 true」ならインデントされたブロック(行)が実行される。
if x > 20:
  print('Bigger')

print('Finis') #インデントが解除されている。o




# 同じ場所を選択する
n = 5

# 「while」は予約語。
# 条件が「false」になるまで、繰り返し選択される。
while n > 0 : #「nが0より大きいですか？」
#「nが0以上ならtrue」という条件。falseになるまで「n」に保存されている値が繰り返し判定される。
  print(n) #「while」の判定が「true」である限り、インデントされたブロックが繰り返し実行される。
  n = n - 1
print('Blastoff!') #インデントが解除されている。


# 定数、constants
# 変更されない

print(123)
print(98.67)
print('Hello World')

# 予約語
# False class return is finally None if for......
#Pythonが条件付き実行を実装するための特別な単語


# ❐❐❐　変数　❐❐❐
# メモリの一部を割りあててから名前を付けるように要求する方法
# その中に何かを入れることができる
x = 12.2

# 変数を制御する方法は、「代入ステートメント」を介して行われる。
# 代入ステートメントには矢印があると考えることが重要
y = 14

# 常に「x = 12.2」、「y = 14」であると言っているわけではない。
# Pythonさん、コンピュータさんに割り当てられたメモリを見つけて「12.2」、「14」を取得しください。
# ラベルx、yをつけて、それぞれのx、yを選択します。
# それが可変部分(variable)
# ラベルxに12.2、ラベルyに14を貼り付ける。

# 「x」に「100」を入れるように指示されているが、「12.2」の古い値が消去され、「100」で"書き換えられる"
# つまり、変数を『変更できる』
x = 100


#命名規則
# 1.文字から始まる
# 2.数字は文字の後
# 3.同じ文字で、大文字小文字による区別の付け方をしない


# good pattern naming
# spam
# eggs
# spam23


# 変数に関することの一つは『名前を選択すること』


# ニーモニックな命名
hours = 35.0 # 時間数
rate = 12.50 # 料金
pay = hours* rate # 給与

# ニーモニック => コンピュータが解釈するマシン語を、人間に分かりやすい形式で表現した記号のこと

# ()の部分が関数の呼び出し「function call」
print(pay)


x = 0.6

# 左側の「x」を変更する前に、先に『右側全体を評価する』のが順番
# 『3.9 × 0.6 × ( 1 - 0.6 )』を行っている。
# 式の結果をxに"戻している"。
x = 3.9 * x * ( 1 - x)

# ❐❐❐　式の結果が変数xに戻されたときに、もともとxに割り当てられていた『古い値を一掃される』　❐❐❐
# そして、新しい値が変数xに代入される。


print(x)





# 式、 Expressions

# 演算子、 Operetor
# 「+」 Addition
# 「-」 Subtraction
# 「*」 Multiplication
# 「/」 Division
# 「**」 Power
# 「%」 Remainder　※モジュロ演算子


# 式の実行順、 Order of Evaluation

x = 1 + 2 * 3 - 4 / 5 ** 6

# 1.Parenthesis () ※括弧のこと
# 2.Power ** べき乗
# 3.Multipication * 乗算、 Division / 割り算、 Remainder % モジュロ演算
# 4.Addition + 足し算、 Substraction - 引き算
# 5.Left to Right 順序が同列なら、左から右に実行


# ()
# **
# *, /, %
# +, -
# Left to Right

print(x)


# tyoe
# 整数型、浮動小数点数型、文字列型

# Pythonでは式を見て自動で型を推論できる。
# この場合は整数型
ddd = 1 + 2
print(ddd, ' 整数型')

# 演算子は型が何かを知って処理することができる
# この場合は文字列の「連結」
eee = 'hello ' + 'there'
print(eee, '文字列型')

# 異なる型の式は評価できない
# eee = 1 + eee　※コンパイルエラーが起きる
# 「Traeeback」は処理をやめたことを意味する

print(type(ddd)) #整数型、int
print(type(eee)) #文字列型, str


# 浮動小数点 + 整数 = 浮動小数点
print(float(99) + 100)
# 199.0

# 整数型
i = 42
print(type(i))
# int

# 浮動小数点型に型変換
f = float(i) # 「float関数」 => 値を浮動小数点に型変換
print(f)
# 42.0

print(type(f))
# float


# 除算
# 整数乗算はPython3.0では浮動小数点の結果を生成する

print(10 / 2)
# 5.0

print(9 / 2)
# 4.5

print(99 / 100)
# 0.99

print(10.0 / 2.0)
# 5.0

print(99.0 / 100.0)
# 0.99





# 文字列、 Sting

# 文字列としての数字
sval = '123'
print(sval, type(sval))


# 整数型を文字列へ型変換
# ❐　『ただし、数字で構成された文字列』に対して整数型への型変換が機能する　❐
ival = int(sval)
print(type(ival))


# 整数型へ型変換を行った為、計算が行えるようになった
print(ival + 1)




# 「入力」と「出力」

# input (Pythonの組み込み関数)
nam = input('Who are you?')
print('Welcome', nam)

# input関数により、「Who are you?」の後にユーザーの入力が期待される
# ❐❐❐　つまり、ユーザーの入力が変数となり、「num」変数にコピーされる代入ステートメントである　❐❐❐
# その後、'Welcome'の文字列と、『ユーザーが入力した文字列』がprint関数で表示される


# Pythonでは常に、右側の式が評価されてから、左の変数に代入される



# 1.『入力』　ユーザーから入力を受け取る
inp = input('Europe floor')

if str.isnumeric(inp):
# 2.『処理』　その入力に対して何らかのタスクを実行
  usf = int(inp) + 1

# 3.『出力』　何らかの出力を生成する、純粋に不可欠なプログラム
  print('US floor', usf)


else:
  print('Please enter a number', inp)